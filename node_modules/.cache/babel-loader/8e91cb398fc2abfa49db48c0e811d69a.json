{"ast":null,"code":"/**\n * Module dependencies.\n */\nvar fs = require('fs'),\n    path = require('path'),\n    join = path.join,\n    dirname = path.dirname,\n    exists = fs.existsSync || path.existsSync,\n    defaults = {\n  arrow: process.env.NODE_BINDINGS_ARROW || ' → ',\n  compiled: process.env.NODE_BINDINGS_COMPILED_DIR || 'compiled',\n  platform: process.platform,\n  arch: process.arch,\n  version: process.versions.node,\n  bindings: 'bindings.node',\n  try: [// node-gyp's linked version in the \"build\" dir\n  ['module_root', 'build', 'bindings'] // node-waf and gyp_addon (a.k.a node-gyp)\n  , ['module_root', 'build', 'Debug', 'bindings'], ['module_root', 'build', 'Release', 'bindings'] // Debug files, for development (legacy behavior, remove for node v0.9)\n  , ['module_root', 'out', 'Debug', 'bindings'], ['module_root', 'Debug', 'bindings'] // Release files, but manually compiled (legacy behavior, remove for node v0.9)\n  , ['module_root', 'out', 'Release', 'bindings'], ['module_root', 'Release', 'bindings'] // Legacy from node-waf, node <= 0.4.x\n  , ['module_root', 'build', 'default', 'bindings'] // Production \"Release\" buildtype binary (meh...)\n  , ['module_root', 'compiled', 'version', 'platform', 'arch', 'bindings']]\n};\n/**\n * The main `bindings()` function loads the compiled bindings for a given module.\n * It uses V8's Error API to determine the parent filename that this function is\n * being invoked from, which is then used to find the root directory.\n */\n\n\nfunction bindings(opts) {\n  // Argument surgery\n  if (typeof opts == 'string') {\n    opts = {\n      bindings: opts\n    };\n  } else if (!opts) {\n    opts = {};\n  }\n\n  opts.__proto__ = defaults; // Get the module root\n\n  if (!opts.module_root) {\n    opts.module_root = exports.getRoot(exports.getFileName());\n  } // Ensure the given bindings name ends with .node\n\n\n  if (path.extname(opts.bindings) != '.node') {\n    opts.bindings += '.node';\n  }\n\n  var tries = [],\n      i = 0,\n      l = opts.try.length,\n      n,\n      b,\n      err;\n\n  for (; i < l; i++) {\n    n = join.apply(null, opts.try[i].map(function (p) {\n      return opts[p] || p;\n    }));\n    tries.push(n);\n\n    try {\n      b = opts.path ? require.resolve(n) : require(n);\n\n      if (!opts.path) {\n        b.path = n;\n      }\n\n      return b;\n    } catch (e) {\n      if (!/not find/i.test(e.message)) {\n        throw e;\n      }\n    }\n  }\n\n  err = new Error('Could not locate the bindings file. Tried:\\n' + tries.map(function (a) {\n    return opts.arrow + a;\n  }).join('\\n'));\n  err.tries = tries;\n  throw err;\n}\n\nmodule.exports = exports = bindings;\n/**\n * Gets the filename of the JavaScript file that invokes this function.\n * Used to help find the root directory of a module.\n * Optionally accepts an filename argument to skip when searching for the invoking filename\n */\n\nexports.getFileName = function getFileName(calling_file) {\n  var origPST = Error.prepareStackTrace,\n      origSTL = Error.stackTraceLimit,\n      dummy = {},\n      fileName;\n  Error.stackTraceLimit = 10;\n\n  Error.prepareStackTrace = function (e, st) {\n    for (var i = 0, l = st.length; i < l; i++) {\n      fileName = st[i].getFileName();\n\n      if (fileName !== __filename) {\n        if (calling_file) {\n          if (fileName !== calling_file) {\n            return;\n          }\n        } else {\n          return;\n        }\n      }\n    }\n  }; // run the 'prepareStackTrace' function above\n\n\n  Error.captureStackTrace(dummy);\n  dummy.stack; // cleanup\n\n  Error.prepareStackTrace = origPST;\n  Error.stackTraceLimit = origSTL;\n  return fileName;\n};\n/**\n * Gets the root directory of a module, given an arbitrary filename\n * somewhere in the module tree. The \"root directory\" is the directory\n * containing the `package.json` file.\n *\n *   In:  /home/nate/node-native-module/lib/index.js\n *   Out: /home/nate/node-native-module\n */\n\n\nexports.getRoot = function getRoot(file) {\n  var dir = dirname(file),\n      prev;\n\n  while (true) {\n    if (dir === '.') {\n      // Avoids an infinite loop in rare cases, like the REPL\n      dir = process.cwd();\n    }\n\n    if (exists(join(dir, 'package.json')) || exists(join(dir, 'node_modules'))) {\n      // Found the 'package.json' file or 'node_modules' dir; we're done\n      return dir;\n    }\n\n    if (prev === dir) {\n      // Got to the top\n      throw new Error('Could not find module root given file: \"' + file + '\". Do you have a `package.json` file? ');\n    } // Try the parent dir next\n\n\n    prev = dir;\n    dir = join(dir, '..');\n  }\n};","map":{"version":3,"sources":["/Users/everyone/Desktop/iPhone app/magic-light/node_modules/bluetooth-serial-port/node_modules/bindings/bindings.js"],"names":["fs","require","path","join","dirname","exists","existsSync","defaults","arrow","process","env","NODE_BINDINGS_ARROW","compiled","NODE_BINDINGS_COMPILED_DIR","platform","arch","version","versions","node","bindings","try","opts","__proto__","module_root","exports","getRoot","getFileName","extname","tries","i","l","length","n","b","err","apply","map","p","push","resolve","e","test","message","Error","a","module","calling_file","origPST","prepareStackTrace","origSTL","stackTraceLimit","dummy","fileName","st","__filename","captureStackTrace","stack","file","dir","prev","cwd"],"mappings":"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","sourcesContent":["\n/**\n * Module dependencies.\n */\n\nvar fs = require('fs')\n  , path = require('path')\n  , join = path.join\n  , dirname = path.dirname\n  , exists = fs.existsSync || path.existsSync\n  , defaults = {\n        arrow: process.env.NODE_BINDINGS_ARROW || ' → '\n      , compiled: process.env.NODE_BINDINGS_COMPILED_DIR || 'compiled'\n      , platform: process.platform\n      , arch: process.arch\n      , version: process.versions.node\n      , bindings: 'bindings.node'\n      , try: [\n          // node-gyp's linked version in the \"build\" dir\n          [ 'module_root', 'build', 'bindings' ]\n          // node-waf and gyp_addon (a.k.a node-gyp)\n        , [ 'module_root', 'build', 'Debug', 'bindings' ]\n        , [ 'module_root', 'build', 'Release', 'bindings' ]\n          // Debug files, for development (legacy behavior, remove for node v0.9)\n        , [ 'module_root', 'out', 'Debug', 'bindings' ]\n        , [ 'module_root', 'Debug', 'bindings' ]\n          // Release files, but manually compiled (legacy behavior, remove for node v0.9)\n        , [ 'module_root', 'out', 'Release', 'bindings' ]\n        , [ 'module_root', 'Release', 'bindings' ]\n          // Legacy from node-waf, node <= 0.4.x\n        , [ 'module_root', 'build', 'default', 'bindings' ]\n          // Production \"Release\" buildtype binary (meh...)\n        , [ 'module_root', 'compiled', 'version', 'platform', 'arch', 'bindings' ]\n        ]\n    }\n\n/**\n * The main `bindings()` function loads the compiled bindings for a given module.\n * It uses V8's Error API to determine the parent filename that this function is\n * being invoked from, which is then used to find the root directory.\n */\n\nfunction bindings (opts) {\n\n  // Argument surgery\n  if (typeof opts == 'string') {\n    opts = { bindings: opts }\n  } else if (!opts) {\n    opts = {}\n  }\n  opts.__proto__ = defaults\n\n  // Get the module root\n  if (!opts.module_root) {\n    opts.module_root = exports.getRoot(exports.getFileName())\n  }\n\n  // Ensure the given bindings name ends with .node\n  if (path.extname(opts.bindings) != '.node') {\n    opts.bindings += '.node'\n  }\n\n  var tries = []\n    , i = 0\n    , l = opts.try.length\n    , n\n    , b\n    , err\n\n  for (; i<l; i++) {\n    n = join.apply(null, opts.try[i].map(function (p) {\n      return opts[p] || p\n    }))\n    tries.push(n)\n    try {\n      b = opts.path ? require.resolve(n) : require(n)\n      if (!opts.path) {\n        b.path = n\n      }\n      return b\n    } catch (e) {\n      if (!/not find/i.test(e.message)) {\n        throw e\n      }\n    }\n  }\n\n  err = new Error('Could not locate the bindings file. Tried:\\n'\n    + tries.map(function (a) { return opts.arrow + a }).join('\\n'))\n  err.tries = tries\n  throw err\n}\nmodule.exports = exports = bindings\n\n\n/**\n * Gets the filename of the JavaScript file that invokes this function.\n * Used to help find the root directory of a module.\n * Optionally accepts an filename argument to skip when searching for the invoking filename\n */\n\nexports.getFileName = function getFileName (calling_file) {\n  var origPST = Error.prepareStackTrace\n    , origSTL = Error.stackTraceLimit\n    , dummy = {}\n    , fileName\n\n  Error.stackTraceLimit = 10\n\n  Error.prepareStackTrace = function (e, st) {\n    for (var i=0, l=st.length; i<l; i++) {\n      fileName = st[i].getFileName()\n      if (fileName !== __filename) {\n        if (calling_file) {\n            if (fileName !== calling_file) {\n              return\n            }\n        } else {\n          return\n        }\n      }\n    }\n  }\n\n  // run the 'prepareStackTrace' function above\n  Error.captureStackTrace(dummy)\n  dummy.stack\n\n  // cleanup\n  Error.prepareStackTrace = origPST\n  Error.stackTraceLimit = origSTL\n\n  return fileName\n}\n\n/**\n * Gets the root directory of a module, given an arbitrary filename\n * somewhere in the module tree. The \"root directory\" is the directory\n * containing the `package.json` file.\n *\n *   In:  /home/nate/node-native-module/lib/index.js\n *   Out: /home/nate/node-native-module\n */\n\nexports.getRoot = function getRoot (file) {\n  var dir = dirname(file)\n    , prev\n  while (true) {\n    if (dir === '.') {\n      // Avoids an infinite loop in rare cases, like the REPL\n      dir = process.cwd()\n    }\n    if (exists(join(dir, 'package.json')) || exists(join(dir, 'node_modules'))) {\n      // Found the 'package.json' file or 'node_modules' dir; we're done\n      return dir\n    }\n    if (prev === dir) {\n      // Got to the top\n      throw new Error('Could not find module root given file: \"' + file\n                    + '\". Do you have a `package.json` file? ')\n    }\n    // Try the parent dir next\n    prev = dir\n    dir = join(dir, '..')\n  }\n}\n"]},"metadata":{},"sourceType":"script"}